<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon Template</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://unpkg.com/earcut@2.1.1/dist/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>

</head>

<body>

    <canvas id="renderCanvas"></canvas>

    <script>

        BABYLON.PolygonMeshBuilder.prototype.wallBuilder = function (w0, w1) {
            var positions = [];
            var iuvs = [];
            var euvs = [];
            var icolors = [];
            var ecolors = [];
            var direction = w1.corner.subtract(w0.corner).normalize();
            var angle = Math.acos(direction.x);
            if (direction.z != 0) {
                angle *= direction.z / Math.abs(direction.z);
            }
            this._points.elements.forEach(function (p) {
                positions.push(p.x * Math.cos(angle) + w0.corner.x, p.y, p.x * Math.sin(angle) + w0.corner.z);
            });
            var indices = [];
            var res = earcut(this._epoints, this._eholes, 2);
            for (var i = res.length; i > 0; i--) {
                indices.push(res[i - 1]);
            };
            return { positions: positions, indices: indices };
        };



        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            // camera
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 3, 75, new BABYLON.Vector3(0, 0, 4.5), scene);
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(5, 10, 0), scene);

            var corner = function (x, y) {
                return new BABYLON.Vector3(x, 0, y);
            }

            var door = function (width, height) {
                this.width = width;
                this.height = height;
                this.left = 0;
            }

            var doorSpace = function (door, left) {
                this.door = door;
                this.left = left;
            }

            var window = function (width, height) {
                this.width = width;
                this.height = height;
                this.left = 0;
                this.bottom = 0;
            }

            var windowSpace = function (window, left, top) {
                this.window = window;
                this.left = left;
                this.top = top;
            }

            var wall = function (corner, doorSpaces, windowSpaces) {
                this.corner = corner;
                this.doorSpaces = doorSpaces || [];
                this.windowSpaces = windowSpaces || [];
            }

            var buildFromPlan = function (walls, ply, height, options, scene) {

                //Arrays for vertex positions and indices
                var positions = [];
                var indices = [];
                var uvs = [];
                var colors = [];

                var interiorUV = options.interiorUV || new BABYLON.Vector4(0, 0, 1, 1);
                var exteriorUV = options.exteriorUV || new BABYLON.Vector4(0, 0, 1, 1);

                var interiorColor = options.interiorColor || new BABYLON.Color4(1, 1, 1, 1);
                var exteriorColor = options.exteriorColor || new BABYLON.Color4(1, 1, 1, 1);
                var interior = options.interior || false;
                if (!interior) {
                    walls.push(walls[0]);
                }

                var interiorIndex;

                //Arrays to hold wall corner data 
                var innerBaseCorners = [];
                var outerBaseCorners = [];
                var innerTopCorners = [];
                var outerTopCorners = [];
                var innerDoorCorners = [];
                var outerDoorCorners = [];
                var innerWindowCorners = [];
                var outerWindowCorners = [];

                var angle = 0;
                var direction = 0;

                var line = BABYLON.Vector3.Zero();
                var nextLine = BABYLON.Vector3.Zero();

                var nbWalls = walls.length;
                if (nbWalls === 2) {
                    walls[1].corner.subtractToRef(walls[0].corner, line);
                    lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
                    line.normalize();
                    innerBaseCorners[0] = walls[0].corner;
                    outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply));
                    innerBaseCorners[1] = walls[1].corner;
                    outerBaseCorners[1] = walls[1].corner.add(lineNormal.scale(ply));
                }
                else if (nbWalls > 2) {
                    for (var w = 0; w < nbWalls - 1; w++) {
                        walls[w + 1].corner.subtractToRef(walls[w].corner, nextLine);
                        angle = Math.PI - Math.acos(BABYLON.Vector3.Dot(line, nextLine) / (line.length() * nextLine.length()));
                        direction = BABYLON.Vector3.Cross(nextLine, line).normalize().y;
                        lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
                        line.normalize();
                        innerBaseCorners[w] = walls[w].corner
                        outerBaseCorners[w] = walls[w].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply / Math.tan(angle / 2)));
                        line = nextLine.clone();
                    }
                    if (interior) {
                        lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
                        line.normalize();
                        innerBaseCorners[nbWalls - 1] = walls[nbWalls - 1].corner
                        outerBaseCorners[nbWalls - 1] = walls[nbWalls - 1].corner.add(lineNormal.scale(ply));
                        walls[1].corner.subtractToRef(walls[0].corner, line);
                        lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
                        line.normalize();
                        innerBaseCorners[0] = walls[0].corner;
                        outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply));
                    }
                    else {
                        walls[1].corner.subtractToRef(walls[0].corner, nextLine);
                        angle = Math.PI - Math.acos(BABYLON.Vector3.Dot(line, nextLine) / (line.length() * nextLine.length()));
                        direction = BABYLON.Vector3.Cross(nextLine, line).normalize().y;
                        lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
                        line.normalize();
                        innerBaseCorners[0] = walls[0].corner
                        outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply / Math.tan(angle / 2)));
                        innerBaseCorners[nbWalls - 1] = innerBaseCorners[0];
                        outerBaseCorners[nbWalls - 1] = outerBaseCorners[0]

                    }
                }

                // inner and outer top corners
                for (var w = 0; w < nbWalls; w++) {
                    innerTopCorners.push(new BABYLON.Vector3(innerBaseCorners[w].x, height, innerBaseCorners[w].z));
                    outerTopCorners.push(new BABYLON.Vector3(outerBaseCorners[w].x, height, outerBaseCorners[w].z));
                }

                var maxL = 0;
                for (w = 0; w < nbWalls - 1; w++) {
                    maxL = Math.max(innerBaseCorners[w + 1].subtract(innerBaseCorners[w]).length(), maxL);
                }

                var maxH = height; // for when gables introduced

                /******House Mesh Construction********/

                // Wall Construction
                var polygonCorners;
                var polygonTriangulation;
                var wallData;
                var wallDirection = BABYLON.Vector3.Zero();
                var wallNormal = BABYLON.Vector3.Zero();
                var wallLength;
                var exteriorWallLength;
                var doorData;
                var windowData;
                var uvx, uvy;
                var wallDiff;

                for (var w = 0; w < nbWalls - 1; w++) {
                    walls[w + 1].corner.subtractToRef(walls[w].corner, wallDirection);
                    wallLength = wallDirection.length();
                    wallDirection.normalize();
                    wallNormal.x = wallDirection.z;
                    wallNormal.z = -1 * wallDirection.x;
                    exteriorWallLength = outerBaseCorners[w + 1].subtract(outerBaseCorners[w]).length();
                    wallDiff = exteriorWallLength - wallLength;
                    var gableHeight = 0;

                    //doors
                    if (walls[w].doorSpaces) {
                        walls[w].doorSpaces.sort(compareLeft);
                    }
                    var doors = walls[w].doorSpaces.length;

                    //Construct INNER wall polygon starting from (0, 0) using wall length and height and door data
                    polygonCorners = [];
                    polygonCorners.push(new BABYLON.Vector2(0, 0));

                    for (var d = 0; d < doors; d++) {
                        polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left, 0));
                        polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left, walls[w].doorSpaces[d].door.height));
                        polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left + walls[w].doorSpaces[d].door.width, walls[w].doorSpaces[d].door.height));
                        polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left + walls[w].doorSpaces[d].door.width, 0));
                    }

                    polygonCorners.push(new BABYLON.Vector2(wallLength, 0));
                    polygonCorners.push(new BABYLON.Vector2(wallLength, height));
                    polygonCorners.push(new BABYLON.Vector2(0, height));

                    //Construct triangulation of polygon using its corners
                    polygonTriangulation = new BABYLON.PolygonMeshBuilder("", polygonCorners, scene);

                    //windows
                    //Construct holes and add to polygon from window data			
                    var windows = walls[w].windowSpaces.length;
                    var holes = [];
                    for (var ws = 0; ws < windows; ws++) {
                        var holeData = [];
                        holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left, height - walls[w].windowSpaces[ws].top - walls[w].windowSpaces[ws].window.height));
                        holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left + walls[w].windowSpaces[ws].window.width, height - walls[w].windowSpaces[ws].top - walls[w].windowSpaces[ws].window.height));
                        holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left + walls[w].windowSpaces[ws].window.width, height - walls[w].windowSpaces[ws].top));
                        holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left, height - walls[w].windowSpaces[ws].top));
                        holes.push(holeData);
                    }

                    for (var h = 0; h < holes.length; h++) {
                        polygonTriangulation.addHole(holes[h]);
                    }


                    // wallBuilder produces wall vertex positions array and indices using the current and next wall to rotate and translate vertex positions to correct place
                    wallData = polygonTriangulation.wallBuilder(walls[w], walls[w + 1]);

                    nbIndices = positions.length / 3; // current number of indices

                    polygonTriangulation._points.elements.forEach(function (p) {
                        uvx = interiorUV.x + p.x * (interiorUV.z - interiorUV.x) / maxL;
                        uvy = interiorUV.y + p.y * (interiorUV.w - interiorUV.y) / height;
                        uvs.push(uvx, uvy);
                        colors.push(interiorColor.r, interiorColor.g, interiorColor.b, interiorColor.a);
                    });

                    //Add inner wall positions (repeated for flat shaded mesh)
                    positions = positions.concat(wallData.positions);

                    interiorIndex = positions.length / 3;

                    indices = indices.concat(wallData.indices.map(function (idx) {
                        return idx + nbIndices;
                    }));

                    //wallData has format for inner wall [base left, 0 or more doors, base right, top right, top left, windows]
                    //extract door and wall data

                    windowData = wallData.positions.slice(12 * (doors + 1)); //4 entries per door + 4 entries for wall corners, each entry has 3 data points
                    doorData = wallData.positions.slice(3, 3 * (4 * doors + 1));

                    //For each inner door save corner as an array of four Vector3s, base left, top left, top right, base right
                    //Extend door data outwards by ply and save outer door corners 		
                    var doorCornersIn = [];
                    var doorCornersOut = [];
                    for (var p = 0; p < doorData.length / 12; p++) {
                        var doorsIn = [];
                        var doorsOut = [];
                        for (var d = 0; d < 4; d++) {
                            doorsIn.push(new BABYLON.Vector3(doorData[3 * d + 12 * p], doorData[3 * d + 12 * p + 1], doorData[3 * d + 12 * p + 2]));
                            doorData[3 * d + 12 * p] += ply * wallNormal.x;
                            doorData[3 * d + 12 * p + 2] += ply * wallNormal.z;
                            doorsOut.push(new BABYLON.Vector3(doorData[3 * d + 12 * p], doorData[3 * d + 12 * p + 1], doorData[3 * d + 12 * p + 2]));
                        }
                        doorCornersIn.push(doorsIn);
                        doorCornersOut.push(doorsOut);
                    }
                    innerDoorCorners.push(doorCornersIn);
                    outerDoorCorners.push(doorCornersOut);

                    //For each inner window save corner as an array of four Vector3s, base left, top left, top right, base right
                    //Extend window data outwards by ply and save outer window corners 		
                    var windowCornersIn = [];
                    var windowCornersOut = [];
                    for (var p = 0; p < windowData.length / 12; p++) {
                        var windowsIn = [];
                        var windowsOut = [];
                        for (var d = 0; d < 4; d++) {
                            windowsIn.push(new BABYLON.Vector3(windowData[3 * d + 12 * p], windowData[3 * d + 12 * p + 1], windowData[3 * d + 12 * p + 2]));
                            windowData[3 * d + 12 * p] += ply * wallNormal.x;
                            windowData[3 * d + 12 * p + 2] += ply * wallNormal.z;
                            windowsOut.push(new BABYLON.Vector3(windowData[3 * d + 12 * p], windowData[3 * d + 12 * p + 1], windowData[3 * d + 12 * p + 2]));
                        }
                        windowCornersIn.push(windowsIn);
                        windowCornersOut.push(windowsOut);
                    }
                    innerWindowCorners.push(windowCornersIn);
                    outerWindowCorners.push(windowCornersOut);

                    //Construct OUTER wall facet positions from inner wall 
                    //Add outer wall corner positions back to wallData positions
                    wallData.positions = [];

                    wallData.positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z);
                    wallData.positions = wallData.positions.concat(doorData);
                    wallData.positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[(w + 1) % nbWalls].z);
                    wallData.positions.push(outerTopCorners[w + 1].x, outerTopCorners[w + 1].y, outerTopCorners[(w + 1) % nbWalls].z);
                    wallData.positions.push(outerTopCorners[w].x, outerTopCorners[w].y, outerTopCorners[w].z);
                    wallData.positions = wallData.positions.concat(windowData);

                    //Calulate exterior wall uvs
                    polygonTriangulation._points.elements.forEach(function (p) {
                        if (p.x == 0) {
                            uvx = exteriorUV.x;
                        }
                        else if (wallLength - p.x < 0.000001) {
                            uvx = exteriorUV.x + (wallDiff + p.x) * (exteriorUV.z - exteriorUV.x) / (maxL + wallDiff)
                        }
                        else {
                            uvx = exteriorUV.x + (0.5 * wallDiff + p.x) * (exteriorUV.z - exteriorUV.x) / (maxL + wallDiff);
                        }
                        uvy = exteriorUV.y + p.y * (exteriorUV.w - exteriorUV.y) / height;
                        uvs.push(uvx, uvy);
                    });

                    nbIndices = positions.length / 3; // current number of indices

                    //Add outer wall positions, uvs and colors (repeated for flat shaded mesh)
                    positions = positions.concat(wallData.positions);


                    //Reverse indices for correct normals
                    wallData.indices.reverse();

                    indices = indices.concat(wallData.indices.map(function (idx) {
                        return idx + nbIndices;
                    }));

                    //Construct facets for base and door top and door sides, repeating positions for flatshaded mesh
                    var doorsRemaining = doors;
                    var doorNb = 0;

                    if (doorsRemaining > 0) {
                        //base
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerBaseCorners[w].x, innerBaseCorners[w].y, innerBaseCorners[w].z); //tl
                        positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z); //bl
                        positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //tr
                        positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //br

                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left				
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].left / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].left / maxL, exteriorUV.y); //base right

                        indices.push(nbIndices, nbIndices + 2, nbIndices + 3, nbIndices + 3, nbIndices + 1, nbIndices);

                        //left side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
                        positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //tr
                        positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //bl
                        positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl

                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top right
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top Left

                        indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices, nbIndices + 3, nbIndices + 2);

                        //top
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //bl
                        positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //br
                        positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl
                        positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                        indices.push(nbIndices + 2, nbIndices + 1, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1);

                        //right side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //tl
                        positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
                        positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr
                        positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //br

                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top Left
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right

                        indices.push(nbIndices, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1, nbIndices + 3);
                    }
                    doorsRemaining--
                    doorNb++

                    while (doorsRemaining > 0) {

                        //base
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb - 1][3].x, innerDoorCorners[w][doorNb - 1][3].y, innerDoorCorners[w][doorNb - 1][3].z); //bl
                        positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
                        positions.push(outerDoorCorners[w][doorNb - 1][3].x, outerDoorCorners[w][doorNb - 1][3].y, outerDoorCorners[w][doorNb - 1][3].z); //tl
                        positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (walls[w].doorSpaces[doorNb].left - (walls[w].doorSpaces[doorNb - 1].left + walls[w].doorSpaces[doorNb - 1].door.width)) / maxL / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (walls[w].doorSpaces[doorNb].left - (walls[w].doorSpaces[doorNb - 1].left + walls[w].doorSpaces[doorNb - 1].door.width)) / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                        indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices + 3, nbIndices + 2, nbIndices);

                        //left side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
                        positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //tr
                        positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //bl
                        positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl

                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top right
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top Left

                        indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices, nbIndices + 3, nbIndices + 2);

                        //top
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //bl
                        positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //br
                        positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl
                        positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                        indices.push(nbIndices + 2, nbIndices + 1, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1);

                        //right side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //tl
                        positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
                        positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr
                        positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //br

                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top Left
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height / maxH); //top right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right

                        indices.push(nbIndices, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1, nbIndices + 3);

                        doorsRemaining--
                        doorNb++

                    }

                    doorNb--;
                    nbIndices = positions.length / 3; // current number of indices

                    //final base
                    if (doors > 0) {
                        positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
                        positions.push(innerBaseCorners[w + 1].x, innerBaseCorners[w + 1].y, innerBaseCorners[w + 1].z); //br
                        positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //tl
                        positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[w + 1].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (wallLength - (walls[w].doorSpaces[doorNb].left + walls[w].doorSpaces[doorNb].door.width)) / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (wallLength - (walls[w].doorSpaces[doorNb].left + walls[w].doorSpaces[doorNb].door.width)) / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                    }
                    else {
                        positions.push(innerBaseCorners[w].x, innerBaseCorners[w].y, innerBaseCorners[w].z); //bl
                        positions.push(innerBaseCorners[w + 1].x, innerBaseCorners[w + 1].y, innerBaseCorners[w + 1].z); //br
                        positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z); //tl
                        positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[w + 1].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * wallLength / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * wallLength / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                    }
                    indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices + 3, nbIndices + 2, nbIndices);

                    //Construct facets for window base, top and sides, repeating positions for flatshaded mesh
                    for (ww = 0; ww < innerWindowCorners[w].length; ww++) {
                        //left side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerWindowCorners[w][ww][3].x, innerWindowCorners[w][ww][3].y, innerWindowCorners[w][ww][3].z); //tr
                        positions.push(innerWindowCorners[w][ww][0].x, innerWindowCorners[w][ww][0].y, innerWindowCorners[w][ww][0].z); //br
                        positions.push(outerWindowCorners[w][ww][3].x, outerWindowCorners[w][ww][3].y, outerWindowCorners[w][ww][3].z); //tl
                        positions.push(outerWindowCorners[w][ww][0].x, outerWindowCorners[w][ww][0].y, outerWindowCorners[w][ww][0].z); //bl

                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height / maxH); //top right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height / maxH); //top Left
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left

                        indices.push(nbIndices + 1, nbIndices, nbIndices + 3, nbIndices + 2, nbIndices + 3, nbIndices);

                        //base
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerWindowCorners[w][ww][0].x, innerWindowCorners[w][ww][0].y, innerWindowCorners[w][ww][0].z); //tl
                        positions.push(innerWindowCorners[w][ww][1].x, innerWindowCorners[w][ww][1].y, innerWindowCorners[w][ww][1].z); //tr
                        positions.push(outerWindowCorners[w][ww][0].x, outerWindowCorners[w][ww][0].y, outerWindowCorners[w][ww][0].z); //bl
                        positions.push(outerWindowCorners[w][ww][1].x, outerWindowCorners[w][ww][1].y, outerWindowCorners[w][ww][1].z); //br

                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width / maxL, exteriorUV.y); //base right

                        indices.push(nbIndices + 1, nbIndices, nbIndices + 3, nbIndices + 3, nbIndices, nbIndices + 2);

                        //right side
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerWindowCorners[w][ww][1].x, innerWindowCorners[w][ww][1].y, innerWindowCorners[w][ww][1].z); //bl
                        positions.push(innerWindowCorners[w][ww][2].x, innerWindowCorners[w][ww][2].y, innerWindowCorners[w][ww][2].z); //tl
                        positions.push(outerWindowCorners[w][ww][1].x, outerWindowCorners[w][ww][1].y, outerWindowCorners[w][ww][1].z); //br
                        positions.push(outerWindowCorners[w][ww][2].x, outerWindowCorners[w][ww][2].y, outerWindowCorners[w][ww][2].z); //tr

                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height / maxH); //top Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x), exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height / maxH); //top right

                        indices.push(nbIndices + 1, nbIndices + 2, nbIndices + 3, nbIndices, nbIndices + 2, nbIndices + 1);

                        //top
                        nbIndices = positions.length / 3; // current number of indices

                        positions.push(innerWindowCorners[w][ww][2].x, innerWindowCorners[w][ww][2].y, innerWindowCorners[w][ww][2].z); //br
                        positions.push(innerWindowCorners[w][ww][3].x, innerWindowCorners[w][ww][3].y, innerWindowCorners[w][ww][3].z); //bl
                        positions.push(outerWindowCorners[w][ww][2].x, outerWindowCorners[w][ww][2].y, outerWindowCorners[w][ww][2].z); //tr
                        positions.push(outerWindowCorners[w][ww][3].x, outerWindowCorners[w][ww][3].y, outerWindowCorners[w][ww][3].z); //tl

                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width / maxL, exteriorUV.y); //base right
                        uvs.push(exteriorUV.x, exteriorUV.y); //base Left
                        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width / maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right
                        uvs.push(exteriorUV.x, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left

                        indices.push(nbIndices + 3, nbIndices, nbIndices + 2, nbIndices + 1, nbIndices, nbIndices + 3);

                    }

                    //Construction of top of wall facets
                    nbIndices = positions.length / 3; // current number of indices

                    positions.push(innerTopCorners[w].x, innerTopCorners[w].y, innerTopCorners[w].z); //tl
                    positions.push(innerTopCorners[w + 1].x, innerTopCorners[w + 1].y, innerTopCorners[w + 1].z); //tr
                    positions.push(outerTopCorners[w].x, outerTopCorners[w].y, outerTopCorners[w].z); //bl
                    positions.push(outerTopCorners[w + 1].x, outerTopCorners[w + 1].y, outerTopCorners[w + 1].z); //br

                    uvx = exteriorUV.x + 0.5 * wallDiff * (exteriorUV.z - exteriorUV.x) / maxL;
                    uvs.push(uvx, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top Left

                    uvx = exteriorUV.x + (0.5 * wallDiff + wallLength) * (exteriorUV.z - exteriorUV.x) / maxL;
                    uvs.push(uvx, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply / maxH); //top right

                    uvs.push(exteriorUV.x, exteriorUV.y); //base Left		
                    uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * exteriorWallLength / (maxL + wallDiff), exteriorUV.y); //base right

                    indices.push(nbIndices + 1, nbIndices, nbIndices + 3, nbIndices + 2, nbIndices + 3, nbIndices);

                    for (var p = interiorIndex; p < positions.length / 3; p++) {
                        colors.push(exteriorColor.r, exteriorColor.g, exteriorColor.b, exteriorColor.a);
                    }

                    var compareLeft = function (a, b) {
                        return a.left - b.left
                    }

                }

                var normals = [];

                BABYLON.VertexData.ComputeNormals(positions, indices, normals);
                BABYLON.VertexData._ComputeSides(BABYLON.Mesh.FRONTSIDE, positions, indices, normals, uvs);


                //Create a custom mesh  
                var customMesh = new BABYLON.Mesh("custom", scene);

                //Create a vertexData object
                var vertexData = new BABYLON.VertexData();

                //Assign positions and indices to vertexData
                vertexData.positions = positions;
                vertexData.indices = indices;
                vertexData.normals = normals;
                vertexData.uvs = uvs;
                vertexData.colors = colors;

                //Apply vertexData to custom mesh
                vertexData.applyToMesh(customMesh);

                return customMesh;

            }
            //***********************************************************************************

            var baseData = [
                0, 0,
                3.0, 0,
                4.0, -3.0,
                10.5, -3.0,
                11.5, 0,
                23, 0,
                23, -2.5,
                32, -2.5,
                32, 52,
                15, 52,
                15, 36,
                0, 36];



            var shape = [];
            // 	new BABYLON.Vector3(0, 0, 0), 
            //     new BABYLON.Vector3(0, 10, 10), 
            //     new BABYLON.Vector3(10, 5, 10), 
            // ];

            for (a = 0; a < baseData.length; a += 2) {
                shape.push(new BABYLON.Vector3(baseData[a], 0, baseData[a + 1]));
            }

            var extrusionDepth = 5;

            //Polygon options as needed
            var options = {
                shape: shape,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }
            var polygon = BABYLON.MeshBuilder.CreatePolygon("polygon", options);




            var corners = [];
            for (b = 0; b < baseData.length / 2; b++) {
                corners.push(new corner(baseData[2 * b], baseData[2 * b + 1]));
            }

            var door2 = new door(3, 8);

            // Standard window
            var window1 = new window(4.5, 5.5);

            var window2 = new window(2.6, 5.6);
            var windowSpace2 = new windowSpace(window2, 0.5, 0.2);

            var window3 = new window(6.3, 5.5);
            var windowSpace3 = new windowSpace(window3, 0.1, 0.2);

            var windowSpace4 = new windowSpace(window2, 0.1, 0.2);

            var walls = [];
            for (c = 0; c < corners.length; c++) {
                walls.push(new wall(corners[c]));
            }

            walls[1].windowSpaces = [windowSpace2];
            walls[2].windowSpaces = [windowSpace3];
            walls[3].windowSpaces = [windowSpace4];

            var letterBoxWindow = new window(10, 2);
            var letterBoxWindowSpace = new windowSpace(letterBoxWindow, 38, 2);

            walls[7].windowSpaces = [letterBoxWindowSpace];

            var frontDoor = new door(3, 8);
            var frontDoorSpace = new doorSpace(frontDoor, 2.5);
            walls[4].doorSpaces = [frontDoorSpace];

            var frontDoorSpace = new doorSpace(frontDoor, 24);
            walls[7].doorSpaces = [frontDoorSpace];

            var garageDoor = new door(7, 8);
            var garageDoorSpace = new doorSpace(garageDoor, 1);
            walls[6].doorSpaces = [garageDoorSpace];

            var slidingDoor = new door(12, 8);
            var slidingDoorSpace = new doorSpace(slidingDoor, 2);
            walls[9].doorSpaces = [slidingDoorSpace];

            walls[10].doorSpaces = [slidingDoorSpace];

            var ply = 0.4;
            var height = 9.6;

            var house = buildFromPlan(walls, ply, height, { interiorUV: new BABYLON.Vector4(0.167, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0, 0, 0.16, 1) }, scene);

            mat = new BABYLON.StandardMaterial("", scene);
            //mat.diffuseTexture = new BABYLON.Texture("https://i.imgur.com/CGTCTfv.jpg", scene);
            mat.diffuseTexture = new BABYLON.Texture("http://i.imgur.com/88fOIk3.jpg", scene);

            house.material = mat;





            // var innerData1 = [-12, 16, -12, -7.5];

            // var corners1 = [];
            // for(b = 0; b < innerData1.length/2; b++) {
            // 	corners1.push(new corner(innerData1[2*b], innerData1[2*b + 1]));
            // }

            // var walls1 = [];
            // for(c=0; c<corners1.length; c++) {
            // 	walls1.push(new wall(corners1[c]));
            // }

            // gDoorSpace = new doorSpace(door2, 19);
            // walls1[0].doorSpaces = [gDoorSpace]

            // var garageWall = buildFromPlan(walls1, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // garageWall.material = mat;

            var sittingRoomWallData = [14.5, 0, 14.5, 14.5, 0, 14.5];

            var corners2 = [];
            for (b = 0; b < sittingRoomWallData.length / 2; b++) {
                corners2.push(new corner(sittingRoomWallData[2 * b], sittingRoomWallData[2 * b + 1]));
            }

            var sittingRoomWalls = [];
            for (c = 0; c < corners2.length; c++) {
                sittingRoomWalls.push(new wall(corners2[c]));
            }

            bDoorSpace = new doorSpace(door2, 11);
            sittingRoomWalls[0].doorSpaces = [bDoorSpace]

            var sittingRoomWall = buildFromPlan(sittingRoomWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            //sittingRoomWall.material = mat;

            // Radiator
            const sittingRoomRadiator = BABYLON.MeshBuilder.CreateBox("box", { height: 2.4, width: 8, depth: 0.25 });
            sittingRoomRadiator.rotation.y = 3.14 / 2;
            sittingRoomRadiator.position = new BABYLON.Vector3(14, 2, 5.5);



            /* Living Room */
            var livingRoomWallData = [14.5, 14.9, 14.5, 36];

            var livingRoomWallCorners = [];
            for (b = 0; b < livingRoomWallData.length / 2; b++) {
                livingRoomWallCorners.push(new corner(livingRoomWallData[2 * b], livingRoomWallData[2 * b + 1]));
            }

            var livingRoomWalls = [];
            for (c = 0; c < livingRoomWallCorners.length; c++) {
                livingRoomWalls.push(new wall(livingRoomWallCorners[c]));
            }

            var wideOpening = new door(10, 8);
            bDoorSpace = new doorSpace(wideOpening, 8);
            livingRoomWalls[0].doorSpaces = [bDoorSpace]

            var livingRoomWall = buildFromPlan(livingRoomWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            //livingRoomWall.material = mat;

            // Radiator
            const livingRoomRadiator = BABYLON.MeshBuilder.CreateBox("box", { height: 2.4, width: 8, depth: 0.25 });
            livingRoomRadiator.position = new BABYLON.Vector3(7, 2, 15.25);


            /* Hallway Room */
            var hallwayWallData = [22.5, 0, 22.5, 19, 14.5, 19];

            var hallwayWallCorners = [];
            for (b = 0; b < hallwayWallData.length / 2; b++) {
                hallwayWallCorners.push(new corner(hallwayWallData[2 * b], hallwayWallData[2 * b + 1]));
            }

            var hallwayWalls = [];
            for (c = 0; c < hallwayWallCorners.length; c++) {
                hallwayWalls.push(new wall(hallwayWallCorners[c]));
            }

            // door2 = new door(10, 8);
            bDoorSpace = new doorSpace(door2, 4);
            hallwayWalls[1].doorSpaces = [bDoorSpace]

            var hallwayWall = buildFromPlan(hallwayWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            //hallwayWall.material = mat;

            // Radiator
            // const livingRoomRadiator = BABYLON.MeshBuilder.CreateBox("box", {height: 2.4, width: 8, depth: 0.25});
            // livingRoomRadiator.position = new BABYLON.Vector3(7, 2, 15);



            /* Kitchen Room */
            var kitchenWallData = [22.5, 19, 22.5, 32, 32, 32];

            var kitchenWallCorners = [];
            for (b = 0; b < kitchenWallData.length / 2; b++) {
                kitchenWallCorners.push(new corner(kitchenWallData[2 * b], kitchenWallData[2 * b + 1]));
            }

            var kitchenWalls = [];
            for (c = 0; c < kitchenWallCorners.length; c++) {
                kitchenWalls.push(new wall(kitchenWallCorners[c]));
            }

            var utilityDoorSpace = new doorSpace(door2, 1);
            kitchenWalls[0].doorSpaces = [utilityDoorSpace]

            var kitchenWall = buildFromPlan(kitchenWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            //hallwayWall.material = mat;



            var garageWallData = [23, 18, 32, 18];

            var garageWallCorners = [];
            for (b = 0; b < garageWallData.length / 2; b++) {
                garageWallCorners.push(new corner(garageWallData[2 * b], garageWallData[2 * b + 1]));
            }

            var garageWalls = [];
            for (c = 0; c < garageWallCorners.length; c++) {
                garageWalls.push(new wall(garageWallCorners[c]));
            }

            var garageWall = buildFromPlan(garageWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);























            /* SECOND FLOOR */

            var baseData1 = [
                0, 0,
                3.0, 0,
                4.0, -3.0,
                10.5, -3.0,
                11.5, 0,
                14.5, 0,
                23, 0,
                32, 0,
                32, 22,
                25, 22,
                25, 32,
                32, 32,
                32, 36,
                0, 36,];


                shape = [];
                for (a = 0; a < baseData1.length; a += 2) {
                    shape.push(new BABYLON.Vector3(baseData1[a], 0, baseData1[a + 1]));
                }

            //Polygon options as needed
            options = {
                shape: shape,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }
            polygon2     = BABYLON.MeshBuilder.CreatePolygon("polygon1", options);
polygon2.position.y = 15;


            var corners1 = [];
            for (b = 0; b < baseData1.length / 2; b++) {
                corners1.push(new corner(baseData1[2 * b], baseData1[2 * b + 1]));
            }

            var walls1 = [];
            for (c = 0; c < corners1.length; c++) {
                walls1.push(new wall(corners1[c]));
            }

            var house2 = buildFromPlan(walls1, ply, height, { interiorUV: new BABYLON.Vector4(0.167, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0, 0, 0.16, 1) }, scene);

            house2.material = mat;

            // Move the floor up atop the ground floor.
            house2.position.y = 15; //(2, 3, 1)





            var frontBedroomWallData = [14.5, 0, 14.5, 14.5, 0, 14.5];

            var frontBedroomCorners = [];
            for (b = 0; b < sittingRoomWallData.length / 2; b++) {
                frontBedroomCorners.push(new corner(frontBedroomWallData[2 * b], frontBedroomWallData[2 * b + 1]));
            }

            var frontBedroomWalls = [];
            for (c = 0; c < corners2.length; c++) {
                frontBedroomWalls.push(new wall(frontBedroomCorners[c]));
            }

            bDoorSpace = new doorSpace(door2, 11);
            frontBedroomWalls[0].doorSpaces = [bDoorSpace]

            var frontBedroomWall = buildFromPlan(frontBedroomWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            frontBedroomWall.position.y = 15;

            // Radiator
            // const sittingRoomRadiator = BABYLON.MeshBuilder.CreateBox("box", { height: 2.4, width: 8, depth: 0.25 });
            // sittingRoomRadiator.rotation.y = 3.14 / 2;
            // // sittingRoomRadiator.position = new BABYLON.Vector3(14, 2, 5.5);



            /* Living Room */
            var masterBedroomWallData = [14.5, 14.9, 14.5, 36];

            var masterBedroomWallCorners = [];
            for (b = 0; b < masterBedroomWallData.length / 2; b++) {
                masterBedroomWallCorners.push(new corner(masterBedroomWallData[2 * b], masterBedroomWallData[2 * b + 1]));
            }

            var masterBedroomWalls = [];
            for (c = 0; c < masterBedroomWallCorners.length; c++) {
                masterBedroomWalls.push(new wall(masterBedroomWallCorners[c]));
            }

            bDoorSpace = new doorSpace(door2, 2);
            masterBedroomWalls[0].doorSpaces = [bDoorSpace]

            var masterBedroomWall = buildFromPlan(masterBedroomWalls, ply, height, { interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior: true }, scene);
            masterBedroomWall.position.y = 15;
            //livingRoomWall.material = mat;

            // // Radiator
            // const livingRoomRadiator = BABYLON.MeshBuilder.CreateBox("box", { height: 2.4, width: 8, depth: 0.25 });
            // livingRoomRadiator.position = new BABYLON.Vector3(7, 2, 15.25);











































            // var innerData3 = [15, 16, 15, 0, 24, 0, 26, 3, 26, 16];

            // var corners3 = [];
            // for(b = 0; b < innerData3.length/2; b++) {
            // 	corners3.push(new corner(innerData3[2*b], innerData3[2*b + 1]));
            // }

            // var walls3 = [];
            // for(c=0; c<corners3.length; c++) {
            // 	walls3.push(new wall(corners3[c]));
            // }

            // mDoorSpace1 = new doorSpace(door2, 2.4);
            // mDoorSpace2 = new doorSpace(door2, 0.2);
            // mDoorSpace3 = new doorSpace(door2, 0.2);
            // walls3[1].doorSpaces = [mDoorSpace1]
            // walls3[2].doorSpaces = [mDoorSpace2];
            // walls3[3].doorSpaces = [mDoorSpace3];

            // var masterWall = buildFromPlan(walls3, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // masterWall.material = mat;

            // var innerData4 = [26, 3, 31, 3];

            // var corners4 = [];
            // for(b = 0; b < innerData4.length/2; b++) {
            // 	corners4.push(new corner(innerData4[2*b], innerData4[2*b + 1]));
            // }

            // var walls4 = [];
            // for(c=0; c<corners4.length; c++) {
            // 	walls4.push(new wall(corners4[c]));
            // }

            // smallWall1 = buildFromPlan(walls4, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // smallWall1.material = mat;

            // var innerData5 = [24, 0, 31, 0];

            // var corners5 = [];
            // for(b = 0; b < innerData5.length/2; b++) {
            // 	corners5.push(new corner(innerData5[2*b], innerData5[2*b + 1]));
            // }

            // var walls5 = [];
            // for(c=0; c<corners5.length; c++) {
            // 	walls5.push(new wall(corners5[c]));
            // }

            // smallWall2 = buildFromPlan(walls5, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // smallWall2.material = mat;

            // var innerData6 = [21, -7.5, 21, 0];

            // var corners6 = [];
            // for(b = 0; b < innerData6.length/2; b++) {
            // 	corners6.push(new corner(innerData6[2*b], innerData6[2*b + 1]));
            // }

            // var walls6 = [];
            // for(c=0; c<corners6.length; c++) {
            // 	walls6.push(new wall(corners6[c]));
            // }

            // cDoorSpace = new doorSpace(door2, 2.25);
            // walls6[0].doorSpaces = [cDoorSpace]

            // smallWall3 = buildFromPlan(walls6, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // smallWall3.material = mat;

            // var innerData7 = [0, -10.5, 0, 3];

            // var corners7 = [];
            // for(b = 0; b < innerData7.length/2; b++) {
            // 	corners7.push(new corner(innerData7[2*b], innerData7[2*b + 1]));
            // }

            // var walls7 = [];
            // for(c=0; c<corners7.length; c++) {
            // 	walls7.push(new wall(corners7[c]));
            // }

            // smallWall4 = buildFromPlan(walls7, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // smallWall4.material = mat;

            // var innerData8 = [0, -2, -12, -2];

            // var corners8 = [];
            // for(b = 0; b < innerData8.length/2; b++) {
            // 	corners8.push(new corner(innerData8[2*b], innerData8[2*b + 1]));
            // }

            // var walls8 = [];
            // for(c=0; c<corners8.length; c++) {
            // 	walls8.push(new wall(corners8[c]));
            // }

            // oDoorSpace = new doorSpace(door2, 8.5);
            // walls8[0].doorSpaces = [oDoorSpace]

            // smallWall5 = buildFromPlan(walls8, ply, height, {interiorUV: new BABYLON.Vector4(0.2, 0, 1, 1), exteriorUV: new BABYLON.Vector4(0.2, 0, 1, 1), interior:true}, scene);
            // smallWall5.material = mat;




            // const ground = BABYLON.MeshBuilder.CreateGround("ground", {height: 50, width: 50, subdivisions: 4});
            // ground.position.x = 20;
            // ground.position.z = 20;



            return scene;

        }

        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        const scene = createScene(); //Call the createScene function
        scene.clearColor = BABYLON.Color3.Black();
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            scene.render();
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>

</body>

</html>