<!DOCTYPE html>
<html>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
<style type="text/css">
    body {
        position: absolute;
        font-size: larger;
    }

    body button {
        font-size: large;
    }

    html,
    body {
        margin: 0;
        padding: 0;
        overflow: y
    }

    svg {
        position: absolute;
        top: 0;
        left: 0;
        height: 1080px;
        width: 1920px;
        z-index: 1;
    }
</style>

<body>

    <div id="app" style="position: relative;">

        <div style="position: relative; z-index: 10;">
            <energyflow-component top="100" left="210" :power="gridPower" width="150"
                positive-direction="left"></energyflow-component>
            <energyflow-component top="100" left="740" :power="solarSystemPower" width="160"
                positive-direction="right"></energyflow-component>
            <energyflow-component top="100" left="1080" :power="pvPower" width="100"
                positive-direction="right"></energyflow-component>
        </div>

        <div style="position: absolute; top: 400px; left: 400px; z-index: 10;">
            <button style="font-size: 50px; width: 150px; border-radius: 10px;"
                :style="{'background-color': this.isHouseTurnedOn ? 'green' : '','color': this.isHouseTurnedOn ? 'white' : ''  }"
                @click="toggleHouseConsumption">{{ this.isHouseTurnedOn ? 'ON' : 'OFF' }}</button>
        </div>

        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1920 1080">

            <defs>

                <g id="meter" class="cube-unit">
                    <rect width="150" height="150" x="1" y="1" fill="white" stroke="black" stroke-width="5" />
                    <text x="10" y="35" font-size="25">GRID</text>
                </g>

                <g id="solar-panel" class="cube-unit">
                    <rect width="70" height="120" x="1" y="1" fill="black" stroke="gray" stroke-width="2" />
                </g>

                <g id="inverter" class="cube-unit">
                    <rect width="150" height="150" x="1" y="1" fill="white" stroke="black" stroke-width="5" />
                    <text x="10" y="35" font-size="25">INVERTER</text>
                </g>

                <g id="consumer-unit" class="cube-unit">
                    <rect width="350" height="200" x="1" y="1" fill="white" stroke="black" stroke-width="5"
                        style="cursor: pointer;" />
                    <text x="10" y="35" font-size="25">CONSUMER UNIT</text>
                </g>

            </defs>

            <use xlink:href="#meter" x="50" y="50" />
            <use xlink:href="#consumer-unit" x="375" y="50" />
            <use v-if="showInverter" xlink:href="#inverter" x="925" y="50" />
            <use v-if="showInverter" xlink:href="#solar-panel" x="1200" y="50" />

        </svg>

        <div style="position: absolute; top: 1200px; left: 400px; z-index: 10;">
            <input id="toggleInverter" type="checkbox" v-model="showInverter" />
            <label for="toggleInverter">Inverter</label>
            <input v-if="showInverter" id="toggleSun" type="checkbox" v-model="showSun" />
            <label v-if="showInverter" for="toggleSun">Sun</label>
            <input type="range" step="1" max="100" min="0" v-model="cloudCover" />
        </div>
        <img src="sun.jpg" v-if="showSun" style="position: absolute; top: 20px; left: 1300px; width: 100px;">
        <img src="cloud.png" v-if="showSun" style="position: absolute; top: 30px; width: 100px;"
            :style="{'left': (parseInt(this.cloudCover) + 1300) + 'px'}">
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script type="text/javascript">
        const { createApp, ref } = Vue;

        var app = createApp({
            setup() {
                const message = ref('Hello vue!')
                return {
                    message
                }
            },
            data() {
                return {
                    showInverter: false,
                    showSun: false,
                    isHouseTurnedOn: false,
                    housePowerConsumption: 500,
                    gridPower: 0,
                    pvPower: 0,
                    solarSystemPower: 0,
                    cloudCover: 0
                }
            },
            watch: {
                showInverter(newValue) {
                    if (!newValue) {
                        this.showSun = false;
                    }
                }
            },
            methods: {
                toggleHouseConsumption() {
                    this.isHouseTurnedOn = !this.isHouseTurnedOn;
                },
                calculatePowerFlow() {

                    if (this.showSun) {
                        this.pvPower = 10 * parseInt(this.cloudCover);
                    } else {
                        this.pvPower = 0;
                    }

                    if (this.showInverter) {
                        // Compute any draw from the battery???
                        this.solarSystemPower = this.pvPower;
                    } else {
                        this.solarSystemPower = 0;
                    }

                    var surplus = 0;
                    var consumption = 0;

                    // Work out the powerflow.
                    //
                    if (this.isHouseTurnedOn) {
                        consumption = this.housePowerConsumption;
                    }

                    surplus = this.solarSystemPower - consumption;

                    this.gridPower = surplus;
                }
            },
            mounted() {
                setInterval(this.calculatePowerFlow, 100);
            }
        });

        app.component('energyflow-component', {
            data() {
                return {
                    pixelsPerSecond: 20,
                    fadeLength: 20,
                    lineWidth: 5,
                    prevTimestamp: undefined,
                    offset: 0,
                    chevronSpace: 12,
                    chevronAngle: 0.7 * Math.PI,
                    chevronLength: 20
                }
            },
            props: ["positive-direction", "power", "top", "left", "width"],
            template:
                `<canvas ref="canvas" style="position: absolute;" :style="{'top': this.top + 'px','left': this.left + 'px'}" width="200" height="75"></canvas>`,
            watch: {
                power(newValue) {

                    console.log({ newValue });
                    console.log(this.positiveDirection);

                    // if (this.positiveDirection === "right") {
                    //     if (this.power < 0) {
                    //         this.x0 = parseInt(this.width);
                    //         this.x1 = 0;
                    //     }
                    //     else {
                    //         this.x1 = 0
                    //         this.x0 = parseInt(this.width);
                    //     }
                    // } else {

                    //     if (this.power > 0) {

                    // LEFT!
                    if (newValue > 0) {
                        this.x0 = parseInt(this.width);
                        this.x1 = 0;
                    }
                    else {
                        this.x0 = 0
                        this.x1 = parseInt(this.width);
                    }

                    this.computeDirection();

                    this.chevronLength = Math.abs(0.05 * this.power);
                }
            },
            methods: {
                computeDirection() {
                    // Angle between our line and the x-axis in radians
                    this.angle = Math.atan2(this.y1 - this.y0, this.x1 - this.x0);

                    // Offset of the first point of a chevron relative to its center point
                    // calculated by subtracting the chevron angle from the line angle
                    this.startX = Math.cos(this.angle - this.chevronAngle) * this.chevronLength;
                    this.startY = Math.sin(this.angle - this.chevronAngle) * this.chevronLength;

                    // Offset of the third point of a chevron relative to its center point
                    // calculated by adding the chevron angle to the line angle
                    this.endX = Math.cos(this.angle + this.chevronAngle) * this.chevronLength;
                    this.endY = Math.sin(this.angle + this.chevronAngle) * this.chevronLength;
                },
                render(timestamp) {

                    const delta = this.prevTimestamp ? timestamp - this.prevTimestamp : 0;
                    this.prevTimestamp = timestamp;

                    const n = Math.floor(this.length / this.chevronSpace);

                    const offsetX = this.offset * Math.cos(this.angle);
                    const offsetY = this.offset * Math.sin(this.angle);

                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    if (this.power !== 0) {
                        this.ctx.lineWidth = this.lineWidth;

                        const red = this.power < 0 ? 200 : 0;
                        const green = this.power > 0 ? 200 : 0;

                        for (let i = 0; i < n; i++) {
                            const x = this.x0 + (this.x1 - this.x0) * i / n + offsetX;
                            const y = this.y0 + (this.y1 - this.y0) * i / n + offsetY;

                            // The opacity depends on how close we are to the start (0) or end
                            // (n * chevronSpace) of the line
                            const dist = Math.min(i * this.chevronSpace + this.offset, n * this.chevronSpace - (i * this.chevronSpace + this.offset));
                            const opacity = Math.min(1, dist / this.fadeLength);

                            const color = `rgba(${red}, ${green}, 0, ${opacity})`;

                            this.ctx.strokeStyle = color;

                            this.ctx.beginPath();
                            this.ctx.moveTo(x + this.startX, y + this.startY);
                            this.ctx.lineTo(x, y);
                            this.ctx.lineTo(x + this.endX, y + this.endY);
                            this.ctx.stroke();
                            this.ctx.font = "28px serif";
                            this.ctx.fillStyle = color;
                            this.ctx.fillText(Math.abs(this.power) + "W",20,20);
                        }
                    }

                    this.offset += this.pixelsPerSecond * delta / 1000;

                    if (this.offset >= this.chevronSpace) {
                        this.offset %= this.chevronSpace;
                    }

                    window.requestAnimationFrame(this.render);
                }
            },
            mounted() {
                this.canvas = this.$refs.canvas;
                this.ctx = this.canvas.getContext("2d");

                this.y0 = 45;
                this.y1 = 45;

                // if (this.positiveDirection === "right") {
                //     if (this.power < 0) {
                //         this.x0 = parseInt(this.width);
                //         this.x1 = 0;
                //     }
                //     else {
                //         this.x1 = 0
                //         this.x0 = parseInt(this.width);
                //     }
                // }
                // // else {

                    if (this.power > 0) {
                        this.x0 = parseInt(this.width);
                        this.x1 = 0;
                    }
                    else {
                        this.x0 = 0
                        this.x1 = parseInt(this.width);
                    }
                // }

                // Length of our line (Euclidean distance)
                this.length = Math.sqrt((this.x0 - this.x1) * (this.x0 - this.x1) + (this.y0 - this.y1) * (this.y0 - this.y1));

                this.computeDirection();

                window.requestAnimationFrame(this.render);
            }
        });

        app.mount('#app')
    </script>
</body>

</html>